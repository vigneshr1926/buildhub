# -*- coding: utf-8 -*-
"""AI MOVIE MATCHMAKER

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NCL1e2qC_T_emFaEGyzOC84gCHm_lEtN
"""

!pip install pandas numpy scikit-learn matplotlib seaborn surprise

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from surprise import Dataset, Reader, SVD
from surprise.model_selection import train_test_split
from sklearn.metrics import mean_squared_error

# Load MovieLens ratings data
ratings_df = pd.read_csv('/content/drive/MyDrive/ratings.csv')
print(ratings_df.head())

# Load TMDb movie metadata
tmdb_metadata = pd.read_csv('/content/drive/MyDrive/tmdb_5000_movies.csv')
print(tmdb_metadata.head())

# Rename columns to make them consistent
tmdb_metadata.rename(columns={'id': 'movieId', 'title': 'tmdb_title', 'genres': 'genres'}, inplace=True)
# If 'id' is not the movie id column, try 'movie_id'
# tmdb_metadata.rename(columns={'movie_id': 'movieId', 'title': 'tmdb_title', 'genres': 'genres'}, inplace=True)


# Merge ratings with movie metadata on movieId
final_df = pd.merge(ratings_df, tmdb_metadata[['movieId', 'tmdb_title', 'genres']], on='movieId', how='left')

# Check the final dataframe
print(final_df.head())

# Prepare data for Surprise library (Reader and Dataset)
reader = Reader(rating_scale=(0.5, 5.0))
data = Dataset.load_from_df(final_df[['userId', 'movieId', 'rating']], reader)

# Split the data into training and testing sets
trainset, testset = train_test_split(data, test_size=0.2)

# Use the SVD algorithm for collaborative filtering
svd = SVD()

# Train the model
svd.fit(trainset)

# Test the model
predictions = svd.test(testset)

# Evaluate the model using RMSE (Root Mean Squared Error)
# The squared parameter was added in scikit-learn version 0.22.
# If you have an older version, calculate RMSE manually.
# rmse = mean_squared_error([pred[2] for pred in predictions], [pred[3] for pred in predictions], squared=False)

# Calculate MSE first
mse = mean_squared_error([pred[2] for pred in predictions], [pred[3] for pred in predictions])

# Then calculate RMSE
rmse = np.sqrt(mse)

print(f"RMSE: {rmse}")

# Function to get movie recommendations for a user
def get_movie_recommendations(user_id, top_n=10):
    # Get a list of all movieIds
    movie_ids = final_df['movieId'].unique()

    # Predict ratings for all movies
    predictions = [svd.predict(user_id, movie_id) for movie_id in movie_ids]

    # Sort predictions by estimated rating
    predictions.sort(key=lambda x: x.est, reverse=True)

    # Get the top N movie recommendations
    top_predictions = predictions[:top_n]

    # Get movie details for the top recommendations
    top_movie_ids = [pred.iid for pred in top_predictions]
    top_movie_titles = final_df[final_df['movieId'].isin(top_movie_ids)]['tmdb_title'].unique()

    return top_movie_titles

# Get movie recommendations for a user
user_id = 1
top_n = 10
recommended_movies = get_movie_recommendations(user_id, top_n)

print(f"Top {top_n} recommendations for User {user_id}:")
for idx, movie in enumerate(recommended_movies, 1):
    print(f"{idx}. {movie}")

# Plot the distribution of ratings
plt.figure(figsize=(8, 6))
sns.histplot(final_df['rating'], bins=10, kde=True)
plt.title('Distribution of Ratings')
plt.xlabel('Rating')
plt.ylabel('Frequency')
plt.show()